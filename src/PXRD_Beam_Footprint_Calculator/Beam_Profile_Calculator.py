# Developed by Mitch S-A
# Updated on August 8, 2025

# ---------- Necessary imports ----------

# Libraries to allow code to interface with other Python scripts
import sys
import subprocess
import os
# Library to allow code to read and write JSON files
import json
# Libraries to allow for trigonometric calculations
import numpy as np
from scipy.optimize import fsolve
# Libraries to allow code to create and output visualizations
import matplotlib.pyplot as plt # For bones of plotting
import matplotlib.ticker as ticker # For granular axes adjustments
import matplotlib.patches as patches # For adding circle and rectangle shapes to Cartesian graphs

# ---------- Short Reference Dictionaries and Lists ----------

# Simple list of holder shapes to more easily expand code applicability in the future
holder_shapes = ["Circle", "Rectangle"]

# Threshold to which incident intensity must be attenuated to pass the z_check
attenuation_threshold = 0.05 # E.g. 0.05 means the X-ray beam must be attenuated to < 5% of it's original intensity by the sample

# ---------- Class Definitions ----------
class DiffractionSample:
    def __init__(self, name, shape, z_check, diameter= 0, axi = 0, equi = 0, MAC = 0, LAC = 0, depth = 0, min_2theta = 0):
        self.name = name
        self.shape = shape
        self.min_2theta = min_2theta
        if self.shape == "Circle":
            self.diameter = diameter
        else:
            self.axi = axi
            self.equi = equi
        self.z_check = z_check
        if self.z_check == True:
            if MAC != 0: # prevents self.MAC from being instantiated as zero
                self.MAC = MAC
            else:
                self.MAC = None # Set to none if user inputs LAC directly, but keeps len(vars()) of object constant
            self.LAC = LAC
        self.depth = depth # Depth must be initialized even if MAC is not to allow users to write custom sample holders for future use

    def __repr__(self):
        string_1 = "A {shape} sample with ".format(shape=self.shape)
        string_2 = ""
        if self.shape == "Circle":
            string_2 = "a diameter of {diameter} mm".format(diameter=self.diameter)
        else:
            string_2 = "dimensions {axi} mm by {equi} mm by {depth} mm deep".format(axi=self.axi, equi=self.equi, depth=self.depth)
        string_3 = ""
        if self.z_check == True:
            string_3 = " and attentuation coefficients of MAC of {MAC} cm^2/g (MAC) and {LAC} cm^-1 (LAC) usable above {min_2theta} degrees 2theta.".format(MAC=self.MAC, LAC=self.LAC, min_2theta=self.min_2theta)
        else:
            string_3 = " usable above {min_2theta} degrees 2theta.".format(min_2theta=self.min_2theta)
        return string_1 + string_2 + string_3

    def print_all_information(self):
        print(vars(self))

class Optics:
    def __init__(self, mode, mask, name="Temp", i_slit=0, i_length=0):
        self.name = name # Passed if the user wants to save the configuration to a JSON under unique name
        self.mode = mode # Either "FDS" or "ADS"
        self.mask = mask
        if self.mode == "FDS":
            self.i_slit = i_slit
        elif self.mode == "ADS":
            self.i_length = i_length

    def __repr__(self):
        string_1 = "An optical configuration using {mode} mode with a {mask} mm beam mask and ".format(mode=self.mode, mask=self.mask)
        string_2 = ""
        if self.mode == "FDS":
            string_2 = "an incident divergence slit of {angle} degrees".format(angle=self.i_slit)
        elif self.mode == "ADS":
            string_2 = "a fixed beam length of {length} mm".format(length=self.i_length)
        string_3 = ""
        if self.name != "Temp":
            string_3 = ", assigned the name \"{name}\".".format(name=self.name)
        else:
            string_3 = "."
        return string_1 + string_2 + string_3

    def print_all_information(self):
        print(vars(self))

    # A function to output all the information of the configuration in a way which is JSON serializable
    def JSON_writable(self):
        components = [] # Establish an empty list to hold all information
        for value in vars(self).values(): # For every value in the key, value pair generated by vars()
            components.append(value)
        return components

# ---------- Simplifying Functions ----------

# Function to get a y or n input from a user input
def y_or_n_confirmation(prompt): # Pass a y/n question as a string to prompt the user
    proceed_with_value = None # Define the returnable boolean that will indicate whether the user said "y" (True) or "n" (False)
    loop_continue = True # Establish a boolean to ensure while loop iterates until "y" or "n" has been found
    while loop_continue: # Loop according to the above boolean
        user_input = input("{} (y/n): ".format(prompt))  # Attempt to get user_input
        if user_input not in ["y", "n"]: # Handle the case where the input is not "y" or "n"
            print("Invalid input. Please enter 'y' or 'n'.") # Prompt new user input
        elif user_input == "y": # User input is "y"
            proceed_with_value = True # The value is confirmed
            loop_continue = False # The loop is ended
        elif user_input == "n": # User input is "n"
            proceed_with_value = False # The value is not confirmed
            loop_continue = False # The loop is ended
    return proceed_with_value # Tells the program whether to proceed with confirmed value (True) or not (False)

# Function to get a float value from the user and confirm proper entry
def get_user_float(prompt, lower_bound = None, upper_bound = None): # Get a float-type input from the user and confirm it is properly entered
    # Optional arguments exist to ensure the number is within a specific range
    returned_value = None # Define a variable to hold the user-confirmed float type value
    loop_continue = True # Establish a boolean to ensure while loop iterates until float value has been confirmed
    while loop_continue: # Loop according to the above boolean
        user_input = input("{} ".format(prompt)) # Prompt the user to input their number
        try: # If the input cannot be made a float, ValueError and throw back to beginning of loop
            user_input_num = float(user_input)
            if lower_bound is not None: # Make sure value is greater than lower bound, if passed
                if user_input_num < lower_bound:
                    print("Invalid input; value too small.")
                    continue
            if upper_bound is not None: # Make sure value is lower than upper bound, if passed
                if user_input_num > upper_bound:
                    print("Invalid input; value too large.")
                    continue
        except ValueError: # Minimal exception handling
            print("Invalid input. Please enter a number.")
            continue
        user_y_or_n = y_or_n_confirmation("You have entered: {}. Is this correct?".format(user_input)) # Call earlier y_or_n to ensure user input is typed correctly
        if user_y_or_n: # If the result of the user confirmation loop is True, return the float value and end the loop
            returned_value = user_input_num
            loop_continue = False
        elif not user_y_or_n: # If the result of the user confirmation loop is False, start from the top of the while loop
            continue
    return returned_value

# Function to get a string value from the user and confirm proper entry
def get_user_string(prompt, max_length = None):
    returned_value = None  # Define a variable to hold the user-confirmed string type value
    loop_continue = True  # Establish a boolean to ensure while loop iterates until string value has been confirmed
    while loop_continue:  # Loop according to the above boolean
        user_input = input("{} ".format(prompt))  # Prompt the user to input their number
        try:  # If the input cannot be made a str, ValueError and throw back to beginning of loop
            user_input_str = str(user_input)
            if max_length is not None:  # Make sure string length is smaller than bound, if passed
                if len(user_input_str) > max_length:
                    print("Invalid input; entry too long.")
                    continue
        except ValueError:  # Minimal exception handling
            print("Invalid input. Please enter text.")
            continue
        user_y_or_n = y_or_n_confirmation("You have entered: {}. Is this correct?".format(
            user_input))  # Call earlier y_or_n to ensure user input is typed correctly
        if user_y_or_n:  # If the result of the user confirmation loop is True, return the float value and end the loop
            returned_value = user_input_str
            loop_continue = False
        elif not user_y_or_n:  # If the result of the user confirmation loop is False, start from the top of the while loop
            continue
    return returned_value

# Function to have user pick from a list of value and confirm proper entry
def user_pick_from(prompt, pick_list): # Present pick list of choices with custom prompt
    confirmed_user_choice = None # Create a variable that will hold the finalized user choice
    loop_continue = True # Establish a boolean to ensure while loop iterates until choice has been confirmed
    while loop_continue: # Loop according to the above boolean
        print("{}".format(prompt)) # Present prompt
        for i in range(0, len(pick_list)): # For loop to present enumerated options
            print("[{bullet}] {option}".format(bullet=i+1, option=pick_list[i]))
        user_selection = input("Please select the number of your choice: ") # Actual prompt for user choice
        try: # Exception handling to make sure value is an integer
            user_selection_num = int(user_selection)
            if int(user_selection) not in range(1, len(pick_list) + 1): # Check to make sure input is within the range of the passed list
                print("Invalid input. Please select a number from the above list.")
                continue
        except ValueError:
            print("Invalid input. Please select a number from the above list.")
            continue
        # Have user confirm their selection
        user_y_or_n = y_or_n_confirmation("You have selected {num}, {choice}. Is this correct? ".format(num=user_selection, choice=pick_list[user_selection_num-1]))
        if user_y_or_n: # If the result of the user confirmation loop is True, return the user choice and end the loop
            confirmed_user_choice = pick_list[user_selection_num-1]
            loop_continue = False
        elif not user_y_or_n: # If the result of the user confirmation loop is False, start from the top of the while loop
            continue
    return confirmed_user_choice

# Function to delete an existing MAC_Calculator_Output.json (i.e. initialize the program)
def delete_MAC_output(filepath):
    if os.path.exists(filepath):
        try:
            os.remove(filepath)
            print("Previous MAC output found and removed - calculator initialized.")
        except OSError as e:
            print("Error initializing calculator: {}".format(e))
    else:
        print("No previous MAC output found - calculator initialized.")

# Function to read in MAC_Calculator_Output.json files
def MAC_Output_Reader(filepath):
    try:
        with open(filepath, "r") as jsonfile: # Basic JSON reading
            MAC_Calc_Output = json.load(jsonfile) # Load the three-item dictionary as a variable
            # return items in bool, float, float order
            return bool(MAC_Calc_Output["check thickness"]), float(MAC_Calc_Output["MAC cm^2/g"]), float(MAC_Calc_Output["LAC cm^-1"])
    except Exception as e:
        print("Error reading MAC calculator output file: {}".format(e))

# Function to take a list and return said list with the "Other" keyword
def othering(my_list):
    list_to_return = list(my_list) # Perhaps redundant, avoids .keys() issue with dictionaries
    list_to_return.append("Other") # Add "Other" as option
    return list_to_return # Return list\

# Function to read in Beam_Calc_JSONs as usable dictionaries of preconfigurations in the script
def load_preconfiguration(filepath):
    try:
        with open(filepath, "r") as jsonfile:
            preconfig_dict = json.load(jsonfile)
            return preconfig_dict
    except Exception as e:
        print("Error loading preconfiguration file: {}".format(e))

# Function to update a JSON with user-desired information
def update_JSON(filepath, key_to_update, new_value):
    data = load_preconfiguration(filepath) # Call JSON reading function to populate a Python dictionary with current JSON
    data_values = list(data.values()) # Load all dict values into a list
    value_type = type(data_values[0]) # Check the type of the first item in the list of dict values (either list or not a list)
    # Test the type of the dictionary's values (list, int) to dictate the procedure for updating the dictionary
    if value_type != list: # If the value is not a list, like float/int for instru_gonio, just do a simple update
        data[key_to_update] = new_value # Perform the update, initializing a new key if the instr does not exist
    elif value_type == list: # If the value is a list, for manu_instr or manu_sample, need to append to existing list
        get_key = data.get(key_to_update, "New Manufacturer") # Get the manufacturer key if it exists, else add new key
        if get_key == "New Manufacturer": # Add new entry since manufacturer does not exist, passing new_value as the sole item in a new list
            data[key_to_update] = [] # Establish an empty list and append, else we get each character of the string appended
            data[key_to_update].append(new_value)
        else: # If the key passed to update_JSON already exists, append the new value to the list
            data[key_to_update].append(new_value)
    try: # Overwrite the previous JSON file with new update
        with open(filepath, "w") as jsonfile:
            json.dump(data, jsonfile, indent=4)
        print("{file} updated.".format(file=filepath))
    except Exception as e:
        print("Error updating JSON file (file): {error}".format(file=filepath, error=e))

# ---------- Gonio and Beam Calculation Functions ----------

# Function to calculate incident divergence slit angle from millimeter width
# Note, this function comes from a Bruker D8 manual where the following {width in mm (w): angle in degrees (phi)} pairs are given:
    # {0.05: 0.025, 0.1: 0.05, 0.2: 0.1, 0.6: 0.3, 1: 0.5, 2: 1, 6: 3}
    # From this and trig, the constant d = 114.59 mm was worked from tan(phi/2) = (w/2)/d
    # As Bruker is the only vendor to the author's knowledge that uses mm, it is assumed these relations hold true for other models and vendors which do the same
def DS_phi_from_mm(millimeter):
    phi = np.degrees(2*np.arctan((millimeter/229.18)))
    return phi

# Function to take LAC in cm^-1 and thickness in mm and return the percent attenuation and thick enough bool
def beer_lambert(LAC, thickness):
    thick_enough = False
    product = (-1) * (LAC * (thickness / 10)) # Convert thickness in mm to cm to get dimensionless exponent
    intensity_ratio = np.exp(product)
    if intensity_ratio < attenuation_threshold: # If incident x-rays are attenuated to (E.g. < 5%) of their original intensity
        thick_enough = True
    else:
        thick_enough = False
    return intensity_ratio, thick_enough

# Function to take LAC in cm^-1 and thickness in mm and return the percent attenuation (above without the bool)
def beer_lambert_atten(LAC, thickness):
    product = (-1) * (LAC * (thickness / 10)) # Convert thickness in mm to cm to get dimensionless exponent
    intensity_ratio = np.exp(product)
    return intensity_ratio

# Function to take LAC in cm^-1 and percent attenuation and return the required thickness in mm
def beer_lambert_layer(LAC, prc_atten):
    thickness = -np.log(prc_atten) / LAC
    return thickness

# Function to return the portion of beam length from incident side to midway point (shorter)
def l_short(radius, phi_degrees, theta_degrees):
    phi_rad = np.deg2rad(phi_degrees)
    theta_rad = np.deg2rad(theta_degrees)
    l_one = (radius * np.sin(phi_rad/2))/(np.sin(theta_rad + (phi_rad/2)))
    return l_one

# Function to return the portion of beam length from midway point to diffracted side (long)
def l_long(radius, phi_degrees, theta_degrees):
    phi_rad = np.deg2rad(phi_degrees)
    theta_rad = np.deg2rad(theta_degrees)
    l_two = (radius * np.sin(phi_rad / 2)) / (np.sin(theta_rad - (phi_rad / 2)))
    return l_two

# Function which finds total length from l_short and l_long in FDS mode
def FDS_length(radius, phi_degrees, min_theta_degrees, max_theta_degrees, step_size_deg=1):
    plotting_data_set = {} # Establish dictionary to hold {theta, beam length} pairs
    for step in range(round(min_theta_degrees), round(max_theta_degrees+1), step_size_deg): # Iterate through provided two-theta range by default of 1 degree increment
        plotting_data_set[step] = float(l_short(radius, phi_degrees, step) + l_long(radius, phi_degrees, step)) # Sum two portions of length and save it as the value for that theta value
    return plotting_data_set # Return dictionary to pass to plotting functions

# Equation to find phi from a given two-theta position in ADS mode
def ADS_equation_for_phi(phi, length, radius, theta):
    # Rearrange the equation for FDS to solve for phi and simplify
    return length * np.cos(phi) - 2 * radius * np.sin(theta) * np.sin(phi) - length * np.cos(2 * theta)

# Solver function to solve phi equation for range of theta's
def phi_solver(length_mm, radius_mm, min_theta_degrees, max_theta_degrees, step_size_deg=1):
    plotting_data_set = {} # Establish dictionary to hold {theta, aperture size} pairs
    initial_guess_phi = np.deg2rad(0.005) # Establish a starting guess of phi's value every time (about 1/4th degree)
    for step in range(round(min_theta_degrees), round(max_theta_degrees+1), step_size_deg): # Iterate through provided two-theta range by default of 1 degree increment
        step_rad = np.deg2rad(step) # Take the theta step we're on and convert it to radians
        phi_solution = fsolve(ADS_equation_for_phi, initial_guess_phi, args=(length_mm, radius_mm, step_rad))
        plotting_data_set[step] = float(np.rad2deg(phi_solution[0])) # fsolve returns a one-item array, result will be in rad so convert to deg
    return plotting_data_set

# Function to determine if rectangular beam can fit inside rectangular sample
def rect_beam_overlap_checker(beam_width, beam_height, sample_width, sample_height):
    return (beam_width <= sample_width and beam_height <= sample_height) # Returns True or False

# Function to determine if rectangular beam can fit inside circular sample
def circ_beam_overlap_checker(beam_width, beam_height, sample_radius):
    half_width = beam_width / 2
    half_height = beam_height / 2
    # Calculate the distance from the center to any corner of the rectangle via Pythagorean Theorem
    distance_to_corner = np.sqrt(half_width**2 + half_height**2)
    # If the distance to the furthest corner is <= the sample's radius, the beam fits!
    return distance_to_corner <= sample_radius # Returns True or False


# ---------- Begin User-Facing Code ----------

if __name__ == "__main__": # All code must go inside in this block to ensure proper resolving between packages

    # Establish pertinent file paths to ensure successful navigation between scripts and JSON loading
    # Get the absolute path to the directory of the current script (PXRD_Beam_Footprint_Calculator, for global reference)
    Beam_Profile_directory = os.path.dirname(os.path.abspath(__file__)) #PXRD_Beam_Footprint_Calculator
    # Build the absolute path to the child script's directory from the directory above (for MAC_JSONs)
    MAC_Calc_directory = os.path.join(Beam_Profile_directory, "MAC_Calculator_Directory") # MAC_Calculator_Directory
    # Build the absolute path to the child script's JSON output in the directory above (for MAC_JSONs)
    MAC_Calc_Output = os.path.join(MAC_Calc_directory, "MAC_Calculator_Output.json") # MAC_Calculator_Directory
    # Build absolute path to the directory containing preconfiguration JSONs (for Beam_Calculation)
    Beam_Calc_J_directory = os.path.join(Beam_Profile_directory, "Beam_Calc_JSONs") # Beam_Calc_JSONs
    # Build absolute path to each preconfiguration JSON (for Beam_Calculation)
    manu_model_path = os.path.join(Beam_Calc_J_directory, "manufacturers_and_models.json")
    manu_samphold_path = os.path.join(Beam_Calc_J_directory, "manufacturers_and_sample_holders.json")
    instru_gonio_path = os.path.join(Beam_Calc_J_directory, "instruments_and_radii.json")
    optics_path = os.path.join(Beam_Calc_J_directory, "preconfig_optics.json")

    # Initialize the calculator by making sure there is no previous MAC Calculator Output
    delete_MAC_output(MAC_Calc_Output)

    # Build pre-configured dictionaries from JSON files
    # General form: manufacturers_models = {"Rigaku": ["SmartLab", "SmartLab SE", "MiniFlex", "MiniFlex XpC"],
    manufacturers_models = load_preconfiguration(manu_model_path)
    # General form: ["Name", "Circle", diameter, depth, min_2theta] or ["Name" "Rectangle", axial dimension, equitorial dimension, depth, min_2theta] with values in mm
        # {"Rigaku": [["Glass 0.2mm", "Rectangle", 15, 15, 0.2, 0], ["Glass 0.5mm", "Rectangle", 15, 15, 0.5, 0], etc.
        # Note that axial is the length of sample well along the beam direction, equitorial is the width of the sample orthogonal to beam direction
    manufacturers_sampleholders = load_preconfiguration(manu_samphold_path)
    # General form: {"X'Pert^3": 240, "X'Pert Pro": 240} with values in mm
    instruments_gonio_radii = load_preconfiguration(instru_gonio_path)

    # Welcome message and state aim of code
    print("""Welcome to the powder XRD beam footprint calculator! This program is designed to help visualize an X-ray
beam's profile on a powder diffraction sample in Bragg-Brentano/reflexion geometry when using divergence slits. Results 
are not guaranteed for the use of focusing mirrors or incident monochromators. I hope it will help you determine the 
best optics settings for your sample, sample holder, and diffractometer when collecting powder X-ray diffraction data.\n""")

    # Establish global boolean for checking sample thickness via MAC
    check_thickness = False
    # Establish global value for sample MAC and LAC
    sample_MAC = 0
    sample_LAC = 0

    # Establish global booleans for saving user inputs as part of the preconfigurations
    save_new_manu_instr = False
    save_new_manu_sample = False
    save_new_radius = False

    # Prompt the user to engage with the MAC_Calculator
    print("""This program has the capability to determine your sample's mass attenuation coefficient (MAC) if you (1) know 
the incident radiation energy (or tube anode material) you will be using and (2) are gathering data on a sample which
does not contain any elements above atomic number (Z) 92. The program will also determine the linear attenuation coefficient 
(LAC) if your sample's density is known, which enables the program to ensure your sample thickness is well-matched to the 
penetration depth of your beam.""")
    throw_to_MAC = y_or_n_confirmation("Would you like to calculate your samples ACs?")
    if not throw_to_MAC: # Do not throw to MAC_Calculator
        estimate_LAC = y_or_n_confirmation("Would you like to provide an estimate of your sample's LAC to be able to check your sample's thickness?")
        if estimate_LAC: # Provide an estimate of MAC
            user_input_LAC = get_user_float("Please enter the LAC of your sample (cm^-1):")
            sample_LAC = float(user_input_LAC)
            check_thickness = True
        elif not estimate_LAC: # Forgo sample thickness calculations
            print("This program will not consider your sample's thickness.")
            check_thickness = False # Change global boolean to skip thickness calculations/visualizations
    elif throw_to_MAC: # Throw to MAC Calculator
        # Write the bash command to execute when moving to the other script
        # -m tells to run it with the name __main__
        # "MAC_Calculator" is the name of the script to run
        bash_command = [sys.executable, "-m", "MAC_Calculator"]  # Specify the command list to throw to the MAC calculator script
        try:
            print("Moving to MAC Calculator...")
            # Change the cwd to the directory in which the script lies so MAC_Calculator can find the JSON files
            subprocess.run(bash_command, cwd=MAC_Calc_directory, check=True)  # Run MAC Calculator script
            print("MAC_Calculator run successfully.")  # Message upon successful completion
        except subprocess.CalledProcessError as e:  # Minimal error handling
            print("An error occurred in calculating the sample MAC: {e}".format(e=e))

    # The script now checks for the existence of MAC_Calculator_Output.json file
    # If it does not exist, the user has either provided the values or decided against them, or check_thickness and sample_MAC are accurate
    # If the file does exist, the code below updates the check_thickness and sample_MAC values to that from MAC_Calculator
    if os.path.exists(MAC_Calc_Output):
        check_thickness, sample_MAC, sample_LAC = MAC_Output_Reader(MAC_Calc_Output)
    # At this point, the thickness check boolean and LAC value are updated and usable - MAC may be zero if LAC is user estimated within BPC.py.
    # Note that MAC will likely go unused in this code, but is still present for archival reasons

    # Prompt user for brand of instrument they are using:
    user_manufacturer = user_pick_from("Please select the manufacturer of your XRD unit from the following:", othering(manufacturers_models.keys()))
    if user_manufacturer == "Other": # If the manufacturer is not included in the preconfigs, ask if they'll want to save this to preconfigurations
        save_this_manu = y_or_n_confirmation("Would you like to save your manufacturer/instrument to the preconfigurations? You will be able to select it directly next time.")
        if save_this_manu: # If yes, change the global boolean that controls this save
            save_new_manu_instr = True
            user_manufacturer = get_user_string("Please enter the manufacturer of your XRD unit:")

    # user_manufacturer can now be from preconfig dictionaries, custom to be saved, or "Other" if we do not want to save

    # Prompt the user for the instrument they are using:
    user_instrument = None # Establish variable on global scale
    try: # If the user_manufacturer is already present in manufacturers_and_models preconfiguration, start by picking from that list
        user_instrument = user_pick_from("Please select the instrument you are using from the following:", othering(manufacturers_models[user_manufacturer]))
        if user_instrument == "Other": # If the manufacturer is known but the instrument is not
            save_this_instr = y_or_n_confirmation("Would you like to save your instrument to the preconfigurations? You will be able to select it directly next time.")
            if save_this_instr:
                save_new_manu_instr = True
                user_instrument =get_user_string("Please enter the instrument you are using:")
    except KeyError: # If the user_manufacturer is "Other" or custom, it will throw a KeyError
        # If the user_manufacturer is custom, save_new_manu_instr is True and the instrument becomes named
        if save_new_manu_instr: # If the user would like to save this new manufacturer/instrument pair:
            user_instrument = get_user_string("Please write the name of the instrument you are using:", 20)
        # If the user_manufacturer was not specified above, it is "Other" and save_new_manu_instr is False
        else:
            user_instrument = "Other"

    # Prompt the user for information about their sample dimensions and flesh out the DiffractionSample class.
    user_holder = None # Establish variable on global scale
    user_holder_information = [] # Establish empty list on global scale
    if user_manufacturer in manufacturers_sampleholders.keys(): # If the manufacturer exists in the manufacturers_and_sample_holders.json
        try: # Add error handling if a manufacturer model exists without any sample holders
            known_compatible_sample_holders = manufacturers_sampleholders[user_manufacturer] # Access list of lists (sample holders) for specified manufacturer
            sample_holder_names = [holder[0] for holder in known_compatible_sample_holders] # List comprehension to generate all holder names
            user_holder = user_pick_from("Please select your sample holder from the following:", othering(sample_holder_names))
            if user_holder != "Other": # User selects a known sample holder from the list, map that info to user_holder_information
                for holder in known_compatible_sample_holders: # For holder info list in all lists for a given manufacturer
                    if holder[0] == user_holder: # If the names match, map the user's sample holder info with the library info and stop looking
                        user_holder_information = holder
                        break
        except Exception as e:
            user_holder = "Other" # Force the user to input sample information as we have no known samples for that manufacturer
    if user_manufacturer not in manufacturers_sampleholders.keys() or user_holder == "Other": # Throw here if user_manufacturer does not exist in the manufacturers_and_sample_holders.json or user_holder is "Other" after above test
        user_holder = "Custom" # Mark the name of this hold as a custom input from the user
        user_holder_information.append(user_holder) # Append this to user_holder_information list to keep standard formatting
        # Populate user_holder_information with custom user inputs
        user_holder_shape = user_pick_from("Please select your sample holder shape:", holder_shapes)
        user_holder_information.append(user_holder_shape)  # Append this shape to user_holder_information list to keep standard formatting
        # Get area dimensions of sample holder according to shape
        if user_holder_shape == "Circle":
            user_diameter = get_user_float("Please input the diameter of your sample holder in mm:")
            user_holder_information.append(user_diameter)
        else: # Assume all other sample holders will need axial and equitorial coordinates
            user_axial = get_user_float("Please input the axial (direction of beam propagation) length of your sample holder in mm:")
            user_holder_information.append(user_axial)
            user_equitorial = get_user_float("Please input the equitorial (orthogonal to beam propagation) width of your sample holder in mm:")
            user_holder_information.append(user_equitorial)
        # Get depth of sample well even if thickness check is not desired so it will be accurate if saved
        user_well_depth = get_user_float("Please input the depth of your sample holder in mm:")
        user_holder_information.append(user_well_depth)
        # Prompt user for minimum 2theta range
        user_holder_angle_limit = get_user_float("If known, please input the minimum 2theta angle at which your sample can be used. Else, write \"0\":")
        user_holder_information.append(user_holder_angle_limit)

    print("Sample information stored.")

    # If the user's sample is custom entered and they have not previously decided against storing the manufacturer, ask if they'd like to store the sample for future use
    # Do not reference save_new_manu_instr boolean, since it will be False if the manufacturer and instrument already exist!
    if user_holder_information[0] == "Custom" and user_manufacturer != "Other":
        update_sampleholder_JSON = y_or_n_confirmation("Would you like to save your custom sample holder for future use under the {} brand?".format(user_manufacturer))
        if update_sampleholder_JSON:
            save_new_manu_sample = True
            user_holder_name = get_user_string("Please name your custom sample holder:", 12)
            user_holder_information[0] = user_holder_name # Update the user holder name to be the user input from above

    # Instantiate the DiffractionSample object with known information
    if user_holder_information[1] == "Circle": # If the holder is circular
        user_diffraction_sample = DiffractionSample(name=user_holder_information[0], shape=user_holder_information[1],
                                                    z_check=check_thickness, diameter=user_holder_information[2],
                                                    MAC=sample_MAC, LAC=sample_LAC, depth=user_holder_information[3],
                                                    min_2theta=user_holder_information[4])
    else: # If the holder is rectangular/square
        user_diffraction_sample = DiffractionSample(name=user_holder_information[0], shape=user_holder_information[1],
                                                    z_check=check_thickness, axi=user_holder_information[2],
                                                    equi=user_holder_information[3], MAC=sample_MAC, LAC=sample_LAC,
                                                    depth=user_holder_information[4],
                                                    min_2theta=user_holder_information[5])

    # Get goniometer radius
    user_gonio_radius = 0 # Establish variable as global
    confirm_radius = False # Establish radius confirmation globally to enable elif statement to update radius if user doesn't like the preconfig
    if user_instrument in instruments_gonio_radii.keys(): # If the user's instrument has an associated radius already
        confirm_radius = y_or_n_confirmation("Your \"{manufacturer}\" {instrument} diffractometer has a radius of {radius}. Is this correct?".format(
            manufacturer=user_manufacturer, instrument=user_instrument, radius=instruments_gonio_radii[user_instrument]))
        if confirm_radius: # The user sees the expect goniometer radius
            user_gonio_radius = instruments_gonio_radii[user_instrument]
            print("Radius confirmed.")
    # If the user's instrument does not exist in instrument_and_radii.json or the value was not user confirmed
    if user_instrument not in instruments_gonio_radii.keys() or not confirm_radius:
        user_gonio_radius = get_user_float("Please enter the radius of your goniometer in mm:") # User inputs a goniometer radius
        if user_instrument != "Other": # If the user opted to store their instrument under a custom name
            store_gonio_radius = y_or_n_confirmation("Would you like to store or update your instruments goniometer radius for future use?")
            if store_gonio_radius: # If they want to store, the global update boolean is updated to True
                save_new_radius = True

    # Now that all required JSONs have been referenced, update them if user requested
    if save_new_manu_sample or save_new_manu_instr or save_new_radius:
        print("Updating JSON files as requested...")

    # Implement JSON updating code
    if save_new_manu_instr:
        update_JSON(manu_model_path, user_manufacturer, user_instrument)
        print("{instrument} was added to {manufacturer}'s library.".format(instrument=user_instrument,
                                                                           manufacturer=user_manufacturer))
    if save_new_manu_sample:
        # List of sample traits we add varies slightly depending on the shape of sample
        if user_diffraction_sample.shape == "Circle":
            update_JSON(manu_samphold_path, user_manufacturer, [user_diffraction_sample.name, user_diffraction_sample.shape, user_diffraction_sample.diameter, user_diffraction_sample.depth, user_diffraction_sample.min_2theta])
        elif user_diffraction_sample.shape == "Rectangle":
            update_JSON(manu_samphold_path, user_manufacturer, [user_diffraction_sample.name, user_diffraction_sample.shape, user_diffraction_sample.axi, user_diffraction_sample.equi, user_diffraction_sample.depth, user_diffraction_sample.min_2theta])
        print("{sample} was added to {manufacturer}'s sample library.".format(sample=user_diffraction_sample.name,
                                                                              manufacturer=user_manufacturer))
    if save_new_radius:
        update_JSON(instru_gonio_path, user_instrument, user_gonio_radius)
        print("{instrument} was given a radius of {radius} mm".format(instrument=user_instrument,
                                                                      radius=user_gonio_radius))

    # Begin portion of code which prompts user for optic components

    boilerplate = user_pick_from("Proceed to optical configuration?", ["Proceed", "Read disclaimer and then proceed"])
    if boilerplate == "Read disclaimer and then proceed":
        print(
"""While the information gathered above is relatively easy to standardize across Bragg-Brentano XRD units, the wide 
variety of optics available renders the applicability of a general use calculator like this one limited even in the best
of circumstances. As a result, the calculator at this time cannot account for the use of incident monochromators, focusing
optics other than typical slits (i.e. mirrors), or the impact of a beam knife blocking signal at high two-theta angles.""")

    # Load preconfig_optics.json to dictionary and check with user to use one of those if the dictionary has a user input
    optic_preconfigurations = load_preconfiguration(optics_path) # Load past settings as options
    optic_preconfig_length = len(list(optic_preconfigurations.keys()))
    if optic_preconfig_length >= 2:  # If the dictionary has more than the basic preconfiguration
        use_past_config = y_or_n_confirmation("Would you like to load a previously used configuration file?")
        if use_past_config: # If the user wants to load a previous configuration
            choose_configuration_list = [key for key in optic_preconfigurations.keys() if key != "Exempt"] # List comprehension to generate pick list below
            configuration_choice = user_pick_from("Please select from the list below:", choose_configuration_list)
            # Because of update_JSON artifact of dealing with lists-of-lists, need to specify a [0] to get to the list of qualities
            user_optics = Optics(optic_preconfigurations[configuration_choice][0][1], optic_preconfigurations[configuration_choice][0][2], optic_preconfigurations[configuration_choice][0][0], optic_preconfigurations[configuration_choice][0][3], optic_preconfigurations[configuration_choice][0][3])
        elif not use_past_config: # If the user does not want to use a past configuration, move to else block below
            pass

    if optic_preconfig_length < 2 or not use_past_config:
        # Ask user if they are running in fixed or variable divergence slit mode
        fixed_or_variable = user_pick_from("Are you operating your instrument in fixed divergence slit (FDS) or variable/automatic divergence slit (ADS) mode?", ["Fixed", "Variable", "Explain"])
        if fixed_or_variable == "Explain": # Offer more information to user on this choice.
            print("""FDS means your divergence slit opening remains constant during your experiment, while the beam length 
changes. This is a constant irradiated volume experiment compatible with Rietveld analysis. ADS refers to a divergence 
slit opening changing over the course of the experiment to keep a constant irradiated length (and therefore area). ADS 
is commonly used for thin-film samples, and not all instruments have ADS capabilities. This choice determines how certain
key math is performed, as well as whether you are presented with a graph of beam length vs. two-theta or divergence slit
opening vs. two-theta.""")
            # Prompt user to update to value to one of two options
            fixed_or_variable = user_pick_from("Are you operating your instrument in fixed divergence slit (FDS) or variable/automatic divergence slit (ADS) mode?", ["Fixed", "Variable"])

        # Get beam length if operating mode is variable
        beam_length = 0 # Establish variable on global scope
        if fixed_or_variable == "Variable":
            beam_length = get_user_float("Please enter your beam length in mm:", 0.0001) # Add lower bound to make sure the value is non-zero

        # Get divergence slit angle if operating mode is fixed
        divergence_slit_angle = 0 # Establish variable on global scope
        if fixed_or_variable == "Fixed":
            slit_form = user_pick_from("""Is your divergence slit provided in degrees or mm? Note that values provided
in degrees will result in more accurate calculations.""", ["Degrees", "Millimeters"])
            # This is because conversion from width to angle requires knowledge of the distance between the x-ray tube and the divergence slit
            if slit_form == "Degrees":
                # Somewhat arbitrary cutoffs for slit size, 1/64 and 8 degrees seeing as I've always seen 1/32 and 4 as the smallest and largest
                divergence_slit_angle = get_user_float("Please enter your divergence slit angle in degrees:", 0.015625, 8)
            elif slit_form == "Millimeters":
                # Impose same cutoffs for slit size in form of mm width
                divergence_slit_width = get_user_float("Please enter your divergence slit width in millimeters:", 0.03125, 16.026)
                divergence_slit_angle = DS_phi_from_mm(divergence_slit_width) # Call function to convert width to angle
                print("Your divergence slit has been converted from {mm} mm to {degrees:.2f} degrees to enable proper calculation.".format(mm=divergence_slit_width, degrees=divergence_slit_angle))

        # Get the beam mask size
        beam_mask_width = get_user_float("""Please provide your beam mask width in mm. \nNOTE: this calculator assumes your instrument uses the common convention of engraving the projected beam width on
the mask, not the actual opening width. For example, a 13 mm mask has a physical opening <13 mm but projects 
a 13 mm wide beam.\nEnter here:""", 0.0001, ) # Add lower bound to make sure the value is non-zero

        # Now that all optics have been provided, prompt the user if they'd like to save and get name if so
        # Establish a boolean to reference whether to save the configuration
        save_optic_configuration =  y_or_n_confirmation("Would you like to save this optical configuration for future use?")
        if save_optic_configuration:
            configuration_name = get_user_string("Please enter your desired name for the optic settings entered:", 20)
        elif not save_optic_configuration:
            configuration_name = "Temp"

        # Instantiate the Optics object
        # Because of how Optics class is written, need an if/elif to convert "Fixed" to "FDS" and "Variable" to "ADS"
        if fixed_or_variable == "Fixed":
            user_optics = Optics("FDS", mask=beam_mask_width, name=configuration_name, i_slit=divergence_slit_angle)
        elif fixed_or_variable == "Variable":
            user_optics = Optics("ADS", mask=beam_mask_width, name=configuration_name, i_length=beam_length)

        # Confirm instantiation and write the Optics object to a preconfiguration if specified by the user
        if save_optic_configuration:
            if configuration_name in list(optic_preconfigurations.keys()): # Simple error handling to avoid null type data
                print("Unable to save your optic settings: name already taken. Please try again later with a different name.")
            else:
                update_JSON(optics_path, user_optics.name, user_optics.JSON_writable())

    print("Optics configured.")

    # Get user two-theta range as minimum and maximum with appropriate flags
    user_min_2theta = get_user_float("Please enter your minimum 2theta angle in degrees:", 0, 180)
    if user_diffraction_sample.min_2theta > user_min_2theta:
        print("Caution: your sample's minimum advisable angle is {minimum} degrees and you intend to begin at {user} degrees. Some of your incident beam may be blocked.".format(minimum=user_diffraction_sample.min_2theta, user=user_min_2theta))
    user_max_2theta = get_user_float("Please enter your maximum 2theta angle in degrees:", 0, 180)
    if user_max_2theta >= 100: # Loose advice, as this program does not flag beam knife interference at high angle
        print("Caution: if you are using a beam knife, check with your manufacturer to see if the knife will cut signal off at high angle.")

    # Inform the user of graphic generation
    generate_visuals_confirm = user_pick_from(
"""Your beam visuals will now be generated. The code will end once you have closed the figure. Details on the compatability 
of your optical choices with your sample will be written in the caption.""", ["See graphics"])

    # Begin with thickness check, if the user's sample is indicated to be compatible with thickness check.
    if user_diffraction_sample.z_check:
        user_intensity, user_z_bool = beer_lambert(user_diffraction_sample.LAC, user_diffraction_sample.depth)
        # Calculate the thickness of a 10 micron (function takes mm, ergo 0.01 mm) layer of sample for graphically comparison
        atten_at_10_microns = beer_lambert_atten(user_diffraction_sample.LAC, 0.01)
        # Calculate thickness required to hit attenuation threshold (E.g. <5% of original intensity)
        layer_to_pass_threshold = beer_lambert_layer(user_diffraction_sample.LAC, attenuation_threshold)

    ### Decide if we want just figures as the output, or verbal prompts as well;
    ### if the latter, standardize to appear before or after figure and change the above code block accordingly

    # Generate data set experiment depending on FDS or ADS mode:
    if user_optics.mode == "FDS": # Generate dictionary of {theta: irradiated length}
        graphable_data_set = FDS_length(user_gonio_radius, user_optics.i_slit, user_min_2theta, user_max_2theta)
    elif user_optics.mode == "ADS": # Generate dictionary of {theta: aperature size}
        graphable_data_set = phi_solver(user_optics.i_length, user_gonio_radius, user_min_2theta, user_max_2theta)

    # Begin portion of the code which generates a visual figure
    #    Recall: convention is that
    #       axial is the length of sample well along the beam direction
    #       equitorial is the width of the sample orthogonal to beam direction

    # Apply global font settings for matplotlib figure
    plt.rcParams['mathtext.fontset'] = 'stix'
    plt.rcParams['font.family'] = 'STIXGeneral'

    # If the user's sample is compatible with thickness check, generate a three-graph figure
    if user_diffraction_sample.z_check:
        fig, graphs = plt.subplots(1, 3, figsize=(18, 6), gridspec_kw={'height_ratios': [1], 'width_ratios': [1, 1, 1]})
    # Else, generate a two-graph figure
    elif not user_diffraction_sample.z_check:
        fig, graphs = plt.subplots(1, 2, figsize=(12, 6), gridspec_kw={'height_ratios': [1], 'width_ratios': [1, 1]})

    # Format Plot One: the graph of beam length (for FDS mode) or aperture size (for ADS mode) against two-theta
    two_theta = graphs[0] # Establish the first Axes object
    # Establish grid with minor ticks
    two_theta.minorticks_on()  # Turns minor gridlines on the graph
    two_theta.grid(True, which="both", linestyle="-", alpha=0.75, linewidth=0.5)  # "which" kwarg adds gridlines for minor ticks
    # Establish gridline settings
    two_theta.xaxis.set_major_formatter(ticker.StrMethodFormatter("{x:,.0f}"))  # Zero decimal places for x-axis
    two_theta.yaxis.set_major_formatter(ticker.StrMethodFormatter("{x:,.2f}"))  # Two decimal places for y-axis
    # Establish settings for x-axis (two-theta)
    two_theta.set_xlim(0, max(list(graphable_data_set.keys())) + 10) # 0, 10 + the user's max two-theta
    two_theta.set_xlabel(r"$2\theta$ (°)", fontsize=12)
    # Check to see optical mode and direct y-axis settings accordingly
    if user_optics.mode == "FDS":
        two_theta.plot(list(graphable_data_set.keys()), list(graphable_data_set.values()), label="FDS", color="blue")
        two_theta.set_title(r"$\text{Beam Length vs. } 2\theta$" ,fontsize=14)
        two_theta.set_ylim(0, max(list(graphable_data_set.values())) + 5) # 0, 5 + the user's max beam length
        two_theta.set_ylabel(r"Beam Length (mm)", fontsize=12)
        # Check to see sample shape and add a horizontal line representing the longest axial dimension of the sample well
        if user_diffraction_sample.shape == "Circle":
            two_theta.axhline(user_diffraction_sample.diameter, color="black", linewidth=1)
        elif user_diffraction_sample.shape == "Rectangle":
            two_theta.axhline(user_diffraction_sample.axi, color="black", linewidth=1)
    elif user_optics.mode == "ADS":
        two_theta.plot(list(graphable_data_set.keys()), list(graphable_data_set.values()), label="ADS", color="red")
        two_theta.set_title(r"$\text{Aperature Width vs. } 2\theta$", fontsize=14)
        two_theta.set_ylim(0, max(list(graphable_data_set.values())) + 0.5)  # 0, 0.5 + the user's max aperture opening
        two_theta.set_ylabel(r"Aperature Width (mm)", fontsize=12)
        # Add a standard horizontal line at 1 mm
        two_theta.axhline(1, color="black", linewidth=1)
    # Add legend now that a label has been generated
    two_theta.legend(edgecolor="black", frameon=True, framealpha=1, loc="upper right")

    # Format Plot 2: visual of beam profile onto sample holder
    beam_profile = graphs[1]
    # Add horizontal line at origin to specify the plane of the gonio
    beam_profile.axhline(0, color="black", linewidth=1.5, label="Plane of the Goniometer")
    # Define positional elements to reference and set locations of patches
    origin = (0, 0)
    # Set the aspect ratio to 'equal' to ensure the circle looks like a circle
    beam_profile.set_aspect('equal', adjustable='box')
    # Add axis labels and a graph title
    beam_profile.set_xlabel("Axial Distance (mm)", fontsize=12)
    beam_profile.set_ylabel("Equitorial Distance (mm)", fontsize=12)
    beam_profile.set_title("Beam Profile projected onto Sample Surface", fontsize=14)
    # Four paths possible, as permutations of ADS vs. FDS and rectangular vs. circular sample
    if user_optics.mode == "FDS" and user_diffraction_sample.shape == "Circle":
        # Create 1 circle patch for sample and 2 rectangle patches for min and max beam
        circle_sample = patches.Circle(origin, (user_diffraction_sample.diameter)/2,
                        label="Sample surface",
                        edgecolor='blue',  # Color of the circle's border
                        facecolor='lightblue',  # Fill color of the circle
                        linewidth=1,  # Width of the border
                        alpha=0.7)  # Transparency
        min_beam_bottom_left = ((0 - (list(graphable_data_set.values())[-1] / 2)), 0 - (user_optics.mask / 2))  # Position the rectangle centered over the origin
        min_beam = patches.Rectangle(min_beam_bottom_left, list(graphable_data_set.values())[-1], user_optics.mask,
                                            label="Smallest beam profile",
                                            edgecolor='red',  # Color of the rectangle's border
                                            facecolor='salmon',  # Fill color of the rectangle
                                            linewidth=1,  # Width of the border
                                            alpha=0.6)  # Transparency
        max_beam_bottom_left = ((0 - (list(graphable_data_set.values())[0] / 2)), 0 - (user_optics.mask / 2))  # Position the rectangle centered over the origin
        max_beam = patches.Rectangle(max_beam_bottom_left, list(graphable_data_set.values())[0], user_optics.mask,
                                            label="Smallest beam profile",
                                            edgecolor='red',  # Color of the rectangle's border
                                            facecolor='salmon',  # Fill color of the rectangle
                                            linewidth=1,  # Width of the border
                                            alpha=0.6)  # Transparency
        # Apply the patches to the plot
        beam_profile.add_patch(circle_sample)
        beam_profile.add_patch(min_beam)
        beam_profile.add_patch(max_beam)
        # Set axis limits for x and y
        beam_profile.set_xlim((-1 * (user_diffraction_sample.diameter / 2) - 5, (user_diffraction_sample.diameter / 2) + 5))
        beam_profile.set_ylim((-1 * (user_diffraction_sample.diameter / 2) - 5, (user_diffraction_sample.diameter / 2) + 5))
    elif user_optics.mode == "FDS" and user_diffraction_sample.shape == "Rectangle":
        # Create 3 rectangle patches, apply them, set axis limits
        # Create 3 rectangle patches for sample, min, and max beam
        rect_sample_bottom_left = ((0 - (user_diffraction_sample.axi / 2)),
                                0 - (user_diffraction_sample.equi / 2)) # Position the rectangle centered over the origin
        rect_sample = patches.Rectangle(rect_sample_bottom_left, user_diffraction_sample.axi, user_diffraction_sample.equi,
                                       label="Sample surface",
                                       edgecolor='blue',  # Color of the rectangle's border
                                       facecolor='lightblue',  # Fill color of the rectangle
                                       linewidth=1,  # Width of the border
                                       alpha=0.7)  # Transparency
        min_beam_bottom_left = ((0 - (list(graphable_data_set.values())[-1] / 2)),
                                0 - (user_optics.mask / 2))  # Position the rectangle centered over the origin
        min_beam = patches.Rectangle(min_beam_bottom_left, list(graphable_data_set.values())[-1], user_optics.mask,
                                     label="Smallest beam profile",
                                     edgecolor='red',  # Color of the rectangle's border
                                     facecolor='salmon',  # Fill color of the rectangle
                                     linewidth=1,  # Width of the border
                                     alpha=0.6)  # Transparency
        max_beam_bottom_left = ((0 - (list(graphable_data_set.values())[0] / 2)),
                                0 - (user_optics.mask / 2))  # Position the rectangle centered over the origin
        max_beam = patches.Rectangle(max_beam_bottom_left, list(graphable_data_set.values())[0], user_optics.mask,
                                     label="Smallest beam profile",
                                     edgecolor='red',  # Color of the rectangle's border
                                     facecolor='salmon',  # Fill color of the rectangle
                                     linewidth=1,  # Width of the border
                                     alpha=0.6)  # Transparency
        # Apply the patches to the plot
        beam_profile.add_patch(rect_sample)
        beam_profile.add_patch(min_beam)
        beam_profile.add_patch(max_beam)
        # Set axis limits for x and y
        beam_profile.set_xlim(
            (-1 * (user_diffraction_sample.axi / 2) - 5, (user_diffraction_sample.axi / 2) + 5))
        beam_profile.set_ylim(
            (-1 * (user_diffraction_sample.equi / 2) - 5, (user_diffraction_sample.equi / 2) + 5))
    elif user_optics.mode == "ADS" and user_diffraction_sample.shape == "Circle":
        # Create 1 circle patch for the sample and 1 rectangle patch for beam
        circle_sample = patches.Circle(origin, (user_diffraction_sample.diameter) / 2,
                                       label="Sample surface",
                                       edgecolor='blue',  # Color of the circle's border
                                       facecolor='lightblue',  # Fill color of the circle
                                       linewidth=1,  # Width of the border
                                       alpha=0.7)  # Transparency
        rect_beam_bottom_left = ((0 - (user_optics.i_length / 2)),
                                0 - (user_optics.mask / 2))  # Position the rectangle centered over the origin
        rect_beam = patches.Rectangle(rect_beam_bottom_left, user_optics.i_length, user_optics.mask,
                                     label="Beam profile",
                                     edgecolor='red',  # Color of the rectangle's border
                                     facecolor='salmon',  # Fill color of the rectangle
                                     linewidth=1,  # Width of the border
                                     alpha=0.6)  # Transparency
        # Add patches to the plot
        beam_profile.add_patch(circle_sample)
        beam_profile.add_patch(rect_beam)
        # Set axis limits for x and y
        beam_profile.set_xlim(
            (-1 * (user_diffraction_sample.diameter / 2) - 5, (user_diffraction_sample.diameter / 2) + 5))
        beam_profile.set_ylim(
            (-1 * (user_diffraction_sample.diameter / 2) - 5, (user_diffraction_sample.diameter / 2) + 5))
    elif user_optics.mode == "ADS" and user_diffraction_sample.shape == "Rectangle":
        # Create 2 rectangle patches for the sample and the beam
        rect_sample_bottom_left = ((0 - (user_diffraction_sample.axi / 2)),
                                   0 - (user_diffraction_sample.equi / 2))  # Position the rectangle centered over the origin
        rect_sample = patches.Rectangle(rect_sample_bottom_left, user_diffraction_sample.axi,
                                        user_diffraction_sample.equi,
                                        label="Sample surface",
                                        edgecolor='blue',  # Color of the rectangle's border
                                        facecolor='lightblue',  # Fill color of the rectangle
                                        linewidth=1,  # Width of the border
                                        alpha=0.7)  # Transparency
        rect_beam_bottom_left = ((0 - (user_optics.i_length / 2)),
                                 0 - (user_optics.mask / 2))  # Position the rectangle centered over the origin
        rect_beam = patches.Rectangle(rect_beam_bottom_left, user_optics.i_length, user_optics.mask,
                                      label="Beam profile",
                                      edgecolor='red',  # Color of the rectangle's border
                                      facecolor='salmon',  # Fill color of the rectangle
                                      linewidth=1,  # Width of the border
                                      alpha=0.6)  # Transparency
        # Add patches to the plot
        beam_profile.add_patch(rect_sample)
        beam_profile.add_patch(rect_beam)
        # Set axis limits for x and y
        beam_profile.set_xlim(
            (-1 * (user_diffraction_sample.axi / 2) - 5, (user_diffraction_sample.axi / 2) + 5))
        beam_profile.set_ylim(
            (-1 * (user_diffraction_sample.equi / 2) - 5, (user_diffraction_sample.equi / 2) + 5))
    # Add legend after label kwargs are established
    beam_profile.legend(edgecolor="black", frameon=True, framealpha=1, loc="upper right")

    # Check if we have a third graph to generate by virtue of z_check:
    if user_diffraction_sample.z_check:
        # Format Plot 3: Beam attenuation by sample as represented with pie chart
        depth_pie = graphs[2]
        # Set title
        depth_pie.set_title("Beam Attenuation Percentage", fontsize=14)
        # Define labels for the pie chart
        pie_labels = ["Attenuated", "Unattenuated", "10 um atten.", "10 um unatten."]
        # Ensure the pie chart renders as a circle with an equal aspect ratio
        depth_pie.set(aspect="equal")
        # Create pie chart data to pass to graphs
        user_outer_pie = [1 - user_intensity, user_intensity] # Outer pie chart of user's sample
        default_inner_pie = [1 - atten_at_10_microns, atten_at_10_microns]  # Inner pie chart that shows attenuation of 10 microns
        # Create outer pie chart which shows the user's attenuation
        depth_pie.pie(user_outer_pie, labels=None,
                      colors=["green", "red"],
                      radius=1,
                      autopct='%1.1f%%',
                      pctdistance=1.2,
                      wedgeprops={'width': 0.3, 'linewidth': 0.3, 'edgecolor': 'white'})
        # Create inner pie chart which shows the attenuation of 10 microns of the user's sample
        depth_pie.pie(default_inner_pie, labels=None,
                      colors=["lightgreen", "salmon"],
                      radius=0.7,
                      autopct='%1.1f%%',
                      pctdistance=0.8,
                      wedgeprops={'width': 0.3, 'linewidth': 0.3, 'edgecolor': 'white'})
        # Create master legend instead on-segment labels
        depth_pie.legend(labels=pie_labels, edgecolor="black", frameon=True, framealpha=1, loc="lower right")

    # Configure the figure-level elements, beginning with title
    fig.suptitle("Your Beam and Sample Interaction Visuals", fontsize=16, fontweight="bold", y=0.95)
    # Text to remark on graphs 1 and 2
    x_y_string = ""
    # Logic to determine if the beam fits inside the sample and set the proper string to remark on graphs 1 and 2
    if user_optics.mode == "FDS" and user_diffraction_sample.shape == "Circle":
        x_y_string = "The graph on the left displays how the beam length will vary over your two-theta range. To the right, two rectangles represent the smallest and largest beam sizes superimposed on your circular sample."
        user_x_y_bool = circ_beam_overlap_checker(list(graphable_data_set.values())[0], user_optics.mask, (user_diffraction_sample.diameter/2))
    elif user_optics.mode == "FDS" and user_diffraction_sample.shape == "Rectangle":
        x_y_string = "The graph on the left displays how the beam length will vary over your two-theta range. To the right, two rectangles represent the smallest and largest beam sizes superimposed on your rectangular sample."
        user_x_y_bool = rect_beam_overlap_checker(list(graphable_data_set.values())[0], user_optics.mask, user_diffraction_sample.axi, user_diffraction_sample.equi)
    elif user_optics.mode == "ADS" and user_diffraction_sample.shape == "Circle":
        x_y_string = "The graph on the left displays how the divergence slit aperture width will vary over your two-theta range. To the right, a rectangle represents the X-ray beam's profile superimposed on your circular sample."
        user_x_y_bool = circ_beam_overlap_checker(user_optics.i_length, user_optics.mask, (user_diffraction_sample.diameter/2))
    elif user_optics.mode == "ADS" and user_diffraction_sample.shape == "Rectangle":
        x_y_string = "The graph on the left displays how the divergence slit aperture width will vary over your two-theta range. To the right, a rectangle represents the X-ray beam's profile superimposed on your rectangular sample."
        user_x_y_bool = rect_beam_overlap_checker(user_optics.i_length, user_optics.mask, user_diffraction_sample.axi, user_diffraction_sample.equi)
    if user_x_y_bool:
        x_y_modifier_string = " Your beam is completely within the bounds of your sample." # Text to add if beam fits on sample
    if not user_x_y_bool:
        x_y_modifier_string = " Your beam expands beyond the scope of the sample well, and your optic choices should be revised." # Text to add if beam does not fit on sample
    # Text to remark on graph 3 if it exists
    z_string = "" # z-string exists in same scope to allow for single additive statement to build caption.
    if user_diffraction_sample.z_check:
        if user_z_bool:  # If the sample well is sufficiently deep for the sample
            passfail = "This means your sample may be considered \"infinitely thick\", and you will not see artifacts from your sample holder."
        elif not user_z_bool:  # If the sample well is not sufficiently deep for the sample
            passfail = "This means your sample may be too thin for your holder, and you may see artifacts from your sample holder (especially at high angle)."
        z_string = "The depth of your sample is {depth:.2f} mm and the linear attenuation coefficient is {LAC:.2f} cm^-1. The inner pie chart displays how much of the X-ray beam would be attenuated by 10 microns of your sample. At the deepest point of your sample, the incident x-rays will be {int:.1g}% of their original intensity. {passfail}".format(
            depth=user_diffraction_sample.depth, LAC=user_diffraction_sample.LAC, int=user_intensity, passfail=passfail)
    # Fill out the caption with concatenation of above strings (FYI: TeX does not work here)
    caption_text = x_y_string + x_y_modifier_string + z_string
    # Add the caption below the plot (adjust the y-coordinate, "y:" based on your plot's layout and figure size
    fig.text(0.5, 0.01,
             s=caption_text,
             wrap=True,  # Wraps text within the figure bounds
             horizontalalignment='center',
             fontsize=10,
             color='black',
             #bbox=dict(facecolor=None, alpha=0.5, boxstyle='round,pad=0.5')
             )
    # Adjust the area between subplots
    fig.subplots_adjust(left=0.1, right=0.9, bottom=0.3, top=0.9, wspace=0.6)
    # Adjust the layout to prevent overlapping elements and increase padding
    plt.tight_layout(pad=3.0)
    # Actually display the figure!
    plt.show()

    print("Thank you for using the Beam Profile Calculator. Happy experimenting!")
    print("Developed by: Mitch S-A")