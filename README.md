# Scripts for Determining the Mass Attenuation Coefficient of a Powder Sample and the Appropriate Optical Settings for a Powder X-Ray Diffractometer
## _For operation in reflexion mode using divergence slits and beam masks_
### by Mitchell Shapiro-Albert
### Updated August 15<sup>th</sup>, 2025
---

## Abstract
This repository contains the scripts and libraries necessary to calculate a powder sample's compatibility with an X-ray diffractometer. "Compatibility" is used in this case to make sure the X-ray beam fits inside the three-dimensional sample. The first part of this compatibility concerns the _z_ direction, having sufficient sample thickness for the incident X-ray energy. This is often only an issue with thin films on the order of 10s of microns thick. It involves the calculation of a sample's attenuation coefficients (ACs). A sample's _mass_ attenuation coefficient (_MAC, cm<sup>2</sup>/g_) is a simple mass-based weighted average of the ACs of its component elements. A sample's _linear_ attenuation coefficient (_LAC,cm<sup>-1</sup>_) is what can be used in Beer's Law to determine the attenuation through a layer of thickness _z_. _LAC_ is calculated by dividing the _MAC_ by the sample's density (g/cm<sup>3</sup>). 

The second portion of "compatibility" is _x-y_, which is whether the profile of the incident beam from the XRD, as shaped by the optics you've chosen, will fit inside the bounds of your sample holder. This is a pretty simple question if you are running your experiment in _automatic divergence slit_ mode, where you set your irradiated length and vary the aperture size of your slit, and/or if your sample is rectangular. However, most powder XRDs fit a square peg (beam) in a round hole (sample holder), which can make it difficult to know if your beam fits, let alone if you're maximizing usage of the available sample surface. Moreover, most XRDs are run in _fixed divergence slit_ mode, where your irradiated length is changing depending on your 2&theta; range. If you irradiate your sample holder at low angle without realizing it, you may encounter confusing systematic errors!

## Disclaimer
The two fundamental scripts in this repository aim to address these two problems in as much breadth as possible to lower the barrier to entry for collecting high-quality diffractograms. It should be noted that the modularity of modern diffraction experimentation makes it hard to catch every combination. To ensure the code written was as accurate as possible, **this script cannot consider non-Bragg-Brentano geometries, transmission experiments, incident monochromators, or focusing mirrors.** This began as an exercise in learning Python, core Python libraries, and Git, so the packaging of the code may be wonky. There is certainly room for optimization, better error handling, and improvements beyond those that the author is even aware of. Many of the solutions implemented were adopted to practice certain Python features rather than because they were the most elegant solution. The creation of classes for the user's sample and optics are two examples of this, as is the approach of breaking this project down into two scripts. However, the latter of these examples does preserve a user's ability to use the _MAC_ calculator independently of the parent Beam Profile Calculator.

## Usage and Permissions
Feel free to use this code for any non-commercial purpose you would like! This was inspired by a much cleaner script from Jordan Cox at MIT.nano, and is my best attempt at an homage to shared usage experimentation facilities. If you use any part of this script to develop a calculator for a tool you own or supervise, know that somewhere I am very happy! For any commercial use questions/licensing, please contact me to discuss.

## Directory Structure
This project uses a relatively straightforward directory structure. The _src_ directory contains the source root code and everything crucial to the program's function. The _Scrapers_ folder contains HTML-scraping programs which were used to build the .json files that _MAC_Calculator.py_ uses (contained in the _JSONs_ folder). You do not need to re-run these scrapers on your local system - they are housed here for reference. _PXRD_Beam_Footprint_Calculator_ is the directory which contains the main, parent script _Beam_Profile_Calculator.py_. It also contains two subdirectories:
1. _MAC_Calculator_Directory_, which itself contains the child script _MAC_Calculator.py_. 
2. _Beam_Calc_JSONs_, which houses preconfigurations for various manufacturers, instrument models, sample holders, and optic choices.

Beyond this, most other files can be ignored. For those new to Python, here are these files' purpose:
+ \__init__._py_ - blank files which indicate the directory containing them is a package, therefore allowing the use of package-level commands when moving between scripts.
+ _MAC_Calculator_Output.json_ - a file which is created at the end of _MAC_Calculator.py_ if the calculated MAC needs to passed back to the _Beam_Profile_Calculator.py_, but is deleted (i.e. initialized) at the start of every call of _Beam_Profile_Calculator.py_.
+ _.gitignore_ - a file which tells Git/Github what parts of the project to ignore for change-tracking purposes (the JSON above is a great example of something that changes constantly and inconsequentially).
+ _Profile_Calculator_Planning.txt_ - an outdated .txt file which helped me plan development of the _Beam_Profile_Calculator.py_ program.
+ _README.md_ - this! A Markdown type file that explains the purpose of the code and how to use it.

## MAC and Beam-Sample Interference Calculations (Child Script: _MAC_Calculator.py_)

_MAC_Calculator.py_ is able to calculate both a MAC and a LAC for your sample and determine the potential interferences with a user provided chemical formula (parsed with the great _chemparse_ library) and a provided incident energy. This script can be run independently if your only aim is to estimate the attenuation coefficients of a sample which does not contain atoms above atomic number (Z >) 92. The inclusion of atoms beyond Uranium will not cause a failure, but the script cannot calculate the ACs of your sample in this case. 

> [!NOTE]
> The attenuation coefficients of your sample are energy-dependent, meaning that the ACs must be re-calculated if you move to a different incident wavelength!
 
The second nifty feature of _MAC_Calculator.py_ is its ability to flag potential beam-sample interferences, like Fe's fluorescence under Cu K-&alpha; radiation. You can select your anode type or input your incident energy (for synchrontrons/free beams) and the program will both automatically check for interferences and, if selected, print out all absorption edges for the elements in your sample with Z < 93. It makes use of the three JSON files in the _JSONS_ directory:

+ **Atomic_MACs.json** - a nested dictionary containing a table of incident energy (keV) vs. elemental mass attenuation coefficient (cm<sup>2</sup>/g) for all elements. Of the form _{{"Z": "keV": MAC, "keV": MAC, etc..._
  + This data comes from [NIST Standard Reference Database 126](https://physics.nist.gov/PhysRefData/XrayMassCoef/tab3.html).
  + The HTML scraper used to convert the tables in the JSON dictionary can be found under _Scrapers > Atomic_LAC_reader.py._ Users should not need to re-scrape.
+ **Element_Information_Dict.json** - a dictionary containing basic information for each element of the form _{"Symbol": ["Z", "Element", "Z/A", "I (eV)", "Density (g/cm3)", "Molecular Weight (g/mol)"], etc..._
  + This data also comes from [NIST Standard Reference Database 126](https://physics.nist.gov/PhysRefData/XrayMassCoef/tab1.html).
  + Google AI mode was used to integrate molecular weight data and format the combination into the JSON file.
+ **X-ray_Absorption_Edges.json** - a dictionary containing a list of all X-ray edge energies for elements Z = 11 to Z = 92 of the form _{"Symbol": [["Edge type", "keV", "Angstrom"]["Edge type", etc..._
  + This data comes from S. Brennan and P.L. Cowan c/o [Ethan A. Merritt at UW](http://skuld.bmsc.washington.edu/scatter/AS_periodic.html)
  + The HTML scraper used to convert the tables in the JSON dictionary can be found under _Scrapers > Absorption_Edge_Reader.py._ Users should not need to re-scrape.
 
After the successful calculation of a MAC, the user is prompted to input their sample's density to generate the requisite LAC to check for appropriate sample thickness. There is an option to have the code generate a mass-based weighted average density, but for the sake of your 8th grade science teacher, don't use this - it was helpful for me for debugging, but the non-additive quality of volume means the LAC will be inaccurate. Once this is generated, you may opt to save the ACs as a .json output (which the _Beam_Profile_Calculator.py_ script will read if you are running _MAC_Calculator.py_ as a child script) or forego saving and quit the program (which means your thickness will not be checked if you are running _MAC_Calculator.py_ as a child script).

The code should be sufficiently commented to be read through with only novice understanding of Python. The program creates a SampleChemistry class that is then instantiated by user inputs. Qualities of the sample itself, like the final sample _MAC_, are saved into class variables. The use of a custom class here is a leftover from a previous structuring of this code, but enough of  _MAC_Calculator.py_ hinged on class functions that the class was kept. Once the program understands the atoms in the user's sample, it will generate smaller dictionaries containing only the key:value pairs of included atoms. These subdictionaries are not saved to class variables, as they were never intended to be passed back to the parent script (below). If the program cannot understand the user's chemical formula, or if it contains elements above Z = 92, it will flag a boolean that will tell the parent script to avoid doing a penetration depth calculation to avoid errors. It will then proceed to offer an interference check on the atoms it does recognize (For Pu<sub>2</sub>Te<sub>2</sub>O<sub>9</sub>, it would check the absorption edges of "Te").

> [!IMPORTANT]
> This code cannot calculate MAC for samples which contain elements above atomic number (Z >) 92, but this will not cause fatal errors.

## Beam Profile Calculations and Visualizations (Parent Script: _Beam_Profile_Calculator.py_)

_Beam_Profile_Calculator.py_ is the main script that will evaluate the optic choices input by the user against and generate a figure to illustrate how the beam profile will interact with the sample. The figure will contain the following:

+ _Left_: A graph of irradiated length vs. 2&theta; if the user is operating in fixed divergence slit mode (FDS, constant irradiated _volume_) **OR** a graph of diffraction slit opening vs. 2&theta; if the user is operating in automatic divergence slit mode (ADS, constant irradiated _area_).
+ _Center_: A visual of the beam profile (singular for ADS, smallest and largest beam for FDS) on the sample holder selected for easy visual reference of whether the beam will fitin _x-y_.
+ _Right (**if** the user has provided ACs)_: a pie chart of what percentage of the incident beam is attenuated by your sample, and for reference, how much of the beam would be attenuated by 10 microns of your sample.

The script begins by asking the user if they want to calculate their ACs, and if so moves them to the child script _MAC_Calculator.py_. If not, the user may input their LAC value directly to still perform a thickness check, or forego the _z_ evaluation entirely. Note that if you had previously calculated a sample's AC and saved it to a .json, that file is erased as soon as the parent script is run.

The program then moves on to find out the relevant pieces of information from the user's instrument and sample, but with the addition of the ability to write the user's entries to the a .json file to allow them to pull them up quickly in the future. Note that a user _must_ specify the make of their instrument to be able to save their instrument and sample, as the .json libraries which house these preconfigurations use the make of the instrument as the key. The user may enter a custom make if theirs is not represented. The .json files are structured as follows:

+ **manufacturers_and_models.json** - a dictionary of manufacturers and instrument models of the form _{"Manufacturer": ["Model 1", "Model 2", etc._
  + This is pre-populated with the most common models from Rigaku, Malvern Panalytical, Bruker, Thermo Fisher, and Proto.
+ **manufacturers_and_sample_holders.json** - a dictionary of manufacturers and compatible sample holders of the form _{"Manufacturer":[["Name", "Shape", x/y dimension or diameter, depth, minimum usable 2&theta;], ["Name", "Shape..._
  + This pre-populated with the most common holders for Rigaku and Malvern Panalytical instruments.
  + The list items within each manufacturer's sub-list are what is required to establish a DiffractionSample object.
+ **instruments_and_radii.json** - a dictionary holding the radii in mm of various instruments of the form _{"Instrument name": radius, "Instrument name"..._
  + All common models in manufacturers_and_models.json have a starting radius.
  + As diffractometers are highly customizable, the script will always prompt the user with the pre-saved radius if is exists in this .json and ensure it is correct.
  + E.g. if you are using a Bruker D8 ADVANCE with a radius of 300, the software will tell you it has 200.5 mm saved and ask you to verify. If you select "n", you will have the option to write 300 mm as the preconfigured radius the next time you run the program.

The idea is that after a few runs, the program will have saved the settings you use most often, and you will not need to custom enter your settings each time. The code will then instantiate your sample with all information to date. Especially important to note here is _user_diffraction_sample.shape_ and _user_diffraction_sample.z_check_, which refer to the shape of the sample as "Circle" or "Rectangle" and whether the program should run portions of the code which check beam attenuation. Many if/elif statements are based on these variables to direct the main portion of the code towards proper calculation methods for your settings. 

After creating the sample (and updating the preconfiguration .jsons if prompted), the user then describes the optical components they will use. There is an empty **preconfig_optics.json** file that can be used to write your most commonly used optical settings to be quick selected once it has an entry. Whether populated through user entries or selected from a pre-configuration, the user_optics instance of the Optics class will contain a _.mode_ attribute to indicate if the user is using "FDS" or "ADS" mode. This (alongside the earlier _user_diffraction_sample.shape_ and _.z_check_) will be used as a check to determine which math to perform and which graphs to display. Regarding the optic choices and calculations, users should be aware of the following:

1. In "FDS" mode, you may enter you divergence slit width in mm instead of in degrees. To the author's knowledge, Bruker is the only manufacturer which ever used this convention, and so the conversion from mm to degrees that the script uses (see _DS_phi_from_mm()_) is based off of Bruker's conversions.
2. The beam mask entry follows Malvern Panalytical's convention of printing the observed equitorial width of the beam on the edge (e.g. their "13 mm" beam mask has an opening of 9 mm cut into it to allow for expansion over a ~100 mm radius)
3. There is a variable _attenuation_threshold_ set early in the code header which establishes that the attenuation of the beam attenuation must be < 5% of its original to pass the thickness test. You may adjust this to whatever acceptance criteria you would like and the figures should change accordingly.
4. All math functions are written in a function section called _Gonio and Beam Calculation Functions_, separate from Python functions I used to simplify the code. Check there for the specifics of how each of these are calculated, as there are ample notes!

Most notably, **there are no guiderails to make sure your instrument has the capabilities you are checking!** You may select "ADS" mode for the Malvern Panalytical Aeris, but that will not mean the Aeris has an automatic divergence slit mode. Most user input restrictions exist to prevent crashes, and not to make sure that your settings are realistic or even possible. The same is true of the last required entry, the user's 2&theta; range, which accepts values from 0° to 180° inclusive. If you are using a sample which has a minimum 2&theta; compatibility (e.g. Malvern spring-loaded samples are ill-advised below 3° 2&theta;), the program will flag that warning but continue. If you are scanning above 100°, the program will recommend you investigate the upper limits of a beam knife installed on your instrument (if applicable). 

> [!TIP]
> This program will not prompt you for antiscatter or soller slit settings, as these do not affect the profile of the beam of the beam on the physical sample. The antiscatter slit blocks errant X-rays, and is often set to be sized one "step" up from their divergence slit in FDS mode (e.g. 1° for a 1/2° divergence slit). In ADS mode, you must examine what your aperature size will be over your 2&theta; range and pick accordingly. The soller slit choice affects the extent of beam collimation, and thus the _full-width at half-maximum intensity_ (FWHM) that is observed. Lower soller slits (0.01°) reduce your intensity and angular breadth, and are effective for Rietveld analysis of complex multi-crystalline mixtures. High soller slits (0.04°) allow more the maximum signal from observed peaks but risk peak overlap, making them best for qualitative examinations and first-pass scans.

At this point, the user's figure will be generated using basic Matplotlib commands, with a custom caption to describe what they are looking at. The caption will confirm whether the optic choices are well determined for the sample provided, however the graphics should provide an "at-a-glance" confirmation. Less time was spent on the generation of the figure, as it was determined that user's would likely want to configure some of these settings to their personal liking. The portion of the code which generates the figures begins (at time of writing) at line 661, and hopefully the extensive notation allows users to quickly find settings they'd like to change. 
