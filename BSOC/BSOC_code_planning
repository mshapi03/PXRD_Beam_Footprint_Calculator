Updated July 28, 2025

PXRD_Sample_Considerations.py is the main script of STIXE
It can pass:
#   (class variable) self.stoich - a dictionary of stoichiometry in the form {"Element" : "Atoms/Molecule"}
#   (global variable) The incident energy the user identified (incident_energy)
# Additionally, if the z_calculable is true (all elements Z > 92) you can pass:
#   (cv) self.molecular_weight_value - the molecular weight of the sample
#   (cv) self.relative_abundance - a dictionary of {"element" : relative abundance}
#   (cv) self.mass_atten_coefficient - the MAC of the sample for the incident energy the user identified
#   (gv) A dictionary of the elemental MACs for the user identified energy (pre-weighted sum)
#   (gv) A dictionary of the elemental absorption edges for the atoms in the sample

Only MAC and incident energy are needed for z calc. No others are passed. If additional things need to be passed, they
must come from updating the STIXE code blocks involving os/sys code.

BSOC imports are managed.

BSOC code classes:

Instrument - self.brand, self.model, self.gonio
# self.brand - will allow the code to check manufacturer to make sure the beam calculations are being performed properly
#   I.e. if there are differences between the calc for a Bruker and Malvern, we can throw to different math functions
# self.model - will allow the code to check and make sure a goniometer configuration is compatible with the instrument model
# self.gonio - holds an instantiated goniometer object (below)
///
# Initially had tube but no longer necessary due to how incident radiation is passed

Goniometer - self.compatible_models, self.geometry, self.radius, self.min_theta, self.max_theta, self.optics
# self.compatible_models is a list of all the XRD
# self.geometry is the geometry of the instrument (reflexion, transmission, parallel-beam, etc.)
# self.radius is the radius of the goniometer
# self.min and max_theta are the scanning range
# self.optics takes an instantiated optics object (below)
///
# self.focus would flag the method of focus, slits or mirrors - only compatible with slits
# self.monochrom would flag an incident monochromator
# .focus and .monochrom will not be incorporated in the current version

Optics - numerical details about configuration
# self.fixed_varied - fixed DS or variable DS mode
# self.mask - beam width limit
# self.i_slit - the divergence angle of the incident slit if operating in fixed DS mode
# self.i_length - the fixed beam length if operating variable DS mode
///
# self.monochrom_angle and self.mirror would expand capabilities to monochromators and mirror focusing

SampleHolder class - numerical details about the sample
# self.shape - either ["Circular", "Square", "Rectangular"]
# Then depending on the shape:
# self.diameter for circular
# self.x for square
# self.x and self.y for rectangle (where y is de facto the longer side)
# self.z for sample well depth if thickness calculation is to be performed

BSOC code will need the following Matplotlib functions:

# Plot irradiated length against 2theta
# Plot divergence slit against 2theta
# Superimpose irradiated footprint on sample x-y
# Superimpose irradiated depth on sample y-z

General workflow of the code is envisioned to be as follows:

### Add here after revising MAC passing to BSOC

References:
# Slide 13 of https://web.stanford.edu/group/glam/xlab/MatSci162_172/LectureNotes/07_Geometry,%20Detectors.pdf
# http://pd.chem.ucl.ac.uk/pdnn/inst1/optics1.htm
# https://imf.ucmerced.edu/sites/g/files/ufvvjh1081/f/page/documents/x-ray_powder_diffraction.pdf
# https://profex.doebelin.org/wp-content/uploads/2014/02/Lesson-2-Diffractometers-and-Phase-Identification.pdf